<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Graphitti: DeviceVector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Graphitti
   </div>
   <div id="projectbrief">A toolkit/software architecture to ease creating high-performance neural network simulators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_device_vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DeviceVector&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3868859e1e687fc6b0c8d050b682e71a" id="r_a3868859e1e687fc6b0c8d050b682e71a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3868859e1e687fc6b0c8d050b682e71a">reference</a></td></tr>
<tr class="memdesc:a3868859e1e687fc6b0c8d050b682e71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type that handles std::vector&lt;bool&gt; specialization.  <br /></td></tr>
<tr class="separator:a3868859e1e687fc6b0c8d050b682e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afdcbf51472ba0977651859a9996644a6" id="r_afdcbf51472ba0977651859a9996644a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdcbf51472ba0977651859a9996644a6">DeviceVector</a> (size_t <a class="el" href="#aaf707b4614c501b08ab94ff9035ab482">size</a>=0)</td></tr>
<tr class="memdesc:afdcbf51472ba0977651859a9996644a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that initializes the host vector without GPU allocation.  <br /></td></tr>
<tr class="separator:afdcbf51472ba0977651859a9996644a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158c161b0abf98e78cf68d8685222191" id="r_a158c161b0abf98e78cf68d8685222191"><td class="memItemLeft" align="right" valign="top"><a id="a158c161b0abf98e78cf68d8685222191" name="a158c161b0abf98e78cf68d8685222191"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceVector</b> (const <a class="el" href="class_device_vector.html">DeviceVector</a> &amp;)=delete</td></tr>
<tr class="memdesc:a158c161b0abf98e78cf68d8685222191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is deleted to prevent accidental copies that could lead to GPU memory leaks. <br /></td></tr>
<tr class="separator:a158c161b0abf98e78cf68d8685222191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69a324f93dcca279d9a6aa678b2eb96" id="r_ac69a324f93dcca279d9a6aa678b2eb96"><td class="memItemLeft" align="right" valign="top"><a id="ac69a324f93dcca279d9a6aa678b2eb96" name="ac69a324f93dcca279d9a6aa678b2eb96"></a>
<a class="el" href="class_device_vector.html">DeviceVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_device_vector.html">DeviceVector</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac69a324f93dcca279d9a6aa678b2eb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is deleted to prevent accidental copies that could lead to GPU memory leaks. <br /></td></tr>
<tr class="separator:ac69a324f93dcca279d9a6aa678b2eb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a789ad4fad85e4bae46b5a0490c0aef" id="r_a4a789ad4fad85e4bae46b5a0490c0aef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a789ad4fad85e4bae46b5a0490c0aef">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4a789ad4fad85e4bae46b5a0490c0aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to the end of the host vector.  <br /></td></tr>
<tr class="separator:a4a789ad4fad85e4bae46b5a0490c0aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513932b94e4c5f24a2ce285cb44f6a99" id="r_a513932b94e4c5f24a2ce285cb44f6a99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a513932b94e4c5f24a2ce285cb44f6a99">resize</a> (size_t new_size)</td></tr>
<tr class="memdesc:a513932b94e4c5f24a2ce285cb44f6a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the host vector to contain new_size elements.  <br /></td></tr>
<tr class="separator:a513932b94e4c5f24a2ce285cb44f6a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27d2dbdd58c11853492dc49eb1c7b6b" id="r_af27d2dbdd58c11853492dc49eb1c7b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af27d2dbdd58c11853492dc49eb1c7b6b">resize</a> (size_t new_size, const T &amp;value)</td></tr>
<tr class="memdesc:af27d2dbdd58c11853492dc49eb1c7b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the host vector to new_size elements, initializing new elements with value.  <br /></td></tr>
<tr class="separator:af27d2dbdd58c11853492dc49eb1c7b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3dc7de0a1a194c2cc4714f0eb40bd1" id="r_ace3dc7de0a1a194c2cc4714f0eb40bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace3dc7de0a1a194c2cc4714f0eb40bd1">clear</a> ()</td></tr>
<tr class="memdesc:ace3dc7de0a1a194c2cc4714f0eb40bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the host vector.  <br /></td></tr>
<tr class="separator:ace3dc7de0a1a194c2cc4714f0eb40bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7533a84e4ae5cefd6797d2e530aa91" id="r_a4c7533a84e4ae5cefd6797d2e530aa91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c7533a84e4ae5cefd6797d2e530aa91">reserve</a> (size_t new_cap)</td></tr>
<tr class="memdesc:a4c7533a84e4ae5cefd6797d2e530aa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves storage in the host vector for at least new_cap elements.  <br /></td></tr>
<tr class="separator:a4c7533a84e4ae5cefd6797d2e530aa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf707b4614c501b08ab94ff9035ab482" id="r_aaf707b4614c501b08ab94ff9035ab482"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf707b4614c501b08ab94ff9035ab482">size</a> () const</td></tr>
<tr class="memdesc:aaf707b4614c501b08ab94ff9035ab482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the host vector.  <br /></td></tr>
<tr class="separator:aaf707b4614c501b08ab94ff9035ab482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa785610e19b2e1ed8db98162a237c771" id="r_aa785610e19b2e1ed8db98162a237c771"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa785610e19b2e1ed8db98162a237c771">empty</a> () const</td></tr>
<tr class="memdesc:aa785610e19b2e1ed8db98162a237c771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the host vector contains no elements.  <br /></td></tr>
<tr class="separator:aa785610e19b2e1ed8db98162a237c771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af321e03c1e3ae97c55422b192bd41400" id="r_af321e03c1e3ae97c55422b192bd41400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af321e03c1e3ae97c55422b192bd41400">assign</a> (size_t n, const T &amp;value)</td></tr>
<tr class="memdesc:af321e03c1e3ae97c55422b192bd41400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces host vector contents with n copies of value.  <br /></td></tr>
<tr class="separator:af321e03c1e3ae97c55422b192bd41400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb016c38909025c94fabb482db4c52b" id="r_aecb016c38909025c94fabb482db4c52b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecb016c38909025c94fabb482db4c52b">getHostVector</a> () const</td></tr>
<tr class="memdesc:aecb016c38909025c94fabb482db4c52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a const reference to the underlying host vector.  <br /></td></tr>
<tr class="separator:aecb016c38909025c94fabb482db4c52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7774106ac9314254e1d96db4bffb6ad1" id="r_a7774106ac9314254e1d96db4bffb6ad1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7774106ac9314254e1d96db4bffb6ad1">getHostVector</a> ()</td></tr>
<tr class="memdesc:a7774106ac9314254e1d96db4bffb6ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a copy of the host vector.  <br /></td></tr>
<tr class="separator:a7774106ac9314254e1d96db4bffb6ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a171a250536b005ea11dff023bf6712" id="r_a7a171a250536b005ea11dff023bf6712"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a171a250536b005ea11dff023bf6712">operator std::vector&lt; T &gt; &amp;</a> ()</td></tr>
<tr class="memdesc:a7a171a250536b005ea11dff023bf6712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion to host vector reference.  <br /></td></tr>
<tr class="separator:a7a171a250536b005ea11dff023bf6712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cbb4eb407e0dd8ebafa6391aa54d2a" id="r_a32cbb4eb407e0dd8ebafa6391aa54d2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32cbb4eb407e0dd8ebafa6391aa54d2a">operator const std::vector&lt; T &gt; &amp;</a> () const</td></tr>
<tr class="memdesc:a32cbb4eb407e0dd8ebafa6391aa54d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion to const host vector reference.  <br /></td></tr>
<tr class="separator:a32cbb4eb407e0dd8ebafa6391aa54d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1171f8d5f5ae3f61ce5f5a3221225404" id="r_a1171f8d5f5ae3f61ce5f5a3221225404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3868859e1e687fc6b0c8d050b682e71a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1171f8d5f5ae3f61ce5f5a3221225404">operator[]</a> (size_t idx)</td></tr>
<tr class="memdesc:a1171f8d5f5ae3f61ce5f5a3221225404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array subscript operator for host vector access.  <br /></td></tr>
<tr class="separator:a1171f8d5f5ae3f61ce5f5a3221225404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0af677afcccdaffa5164aab2097c61" id="r_aaa0af677afcccdaffa5164aab2097c61"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa0af677afcccdaffa5164aab2097c61">operator[]</a> (size_t idx) const</td></tr>
<tr class="memdesc:aaa0af677afcccdaffa5164aab2097c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const array subscript operator for host vector access.  <br /></td></tr>
<tr class="separator:aaa0af677afcccdaffa5164aab2097c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3102239a0555af7f8679b3eccc290e" id="r_afd3102239a0555af7f8679b3eccc290e"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd3102239a0555af7f8679b3eccc290e">data</a> ()</td></tr>
<tr class="memdesc:afd3102239a0555af7f8679b3eccc290e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to contiguous host memory array.  <br /></td></tr>
<tr class="separator:afd3102239a0555af7f8679b3eccc290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be36f08d2e77995f7b7a9b7e2c83de5" id="r_a7be36f08d2e77995f7b7a9b7e2c83de5"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7be36f08d2e77995f7b7a9b7e2c83de5">data</a> () const</td></tr>
<tr class="memdesc:a7be36f08d2e77995f7b7a9b7e2c83de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets const pointer to contiguous host memory array.  <br /></td></tr>
<tr class="separator:a7be36f08d2e77995f7b7a9b7e2c83de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522f1cd75f0251151eaa7d2a16fad27b" id="r_a522f1cd75f0251151eaa7d2a16fad27b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a522f1cd75f0251151eaa7d2a16fad27b">at</a> (size_t idx)</td></tr>
<tr class="memdesc:a522f1cd75f0251151eaa7d2a16fad27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe element access for host vector with bounds checking.  <br /></td></tr>
<tr class="separator:a522f1cd75f0251151eaa7d2a16fad27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f168be854b36b73bcb7d73507da2e3d" id="r_a2f168be854b36b73bcb7d73507da2e3d"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f168be854b36b73bcb7d73507da2e3d">at</a> (size_t idx) const</td></tr>
<tr class="memdesc:a2f168be854b36b73bcb7d73507da2e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe const element access for host vector with bounds checking.  <br /></td></tr>
<tr class="separator:a2f168be854b36b73bcb7d73507da2e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871c733dd79a61d38df58485f59d34a5" id="r_a871c733dd79a61d38df58485f59d34a5"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a871c733dd79a61d38df58485f59d34a5">front</a> ()</td></tr>
<tr class="memdesc:a871c733dd79a61d38df58485f59d34a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element of host vector.  <br /></td></tr>
<tr class="separator:a871c733dd79a61d38df58485f59d34a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b47d0c50a48722d2bab574bb15c9c4" id="r_ad8b47d0c50a48722d2bab574bb15c9c4"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8b47d0c50a48722d2bab574bb15c9c4">front</a> () const</td></tr>
<tr class="memdesc:ad8b47d0c50a48722d2bab574bb15c9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element of host vector (const)  <br /></td></tr>
<tr class="separator:ad8b47d0c50a48722d2bab574bb15c9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2545e88ca6e05c22f4692625df46e228" id="r_a2545e88ca6e05c22f4692625df46e228"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2545e88ca6e05c22f4692625df46e228">back</a> ()</td></tr>
<tr class="memdesc:a2545e88ca6e05c22f4692625df46e228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element of host vector.  <br /></td></tr>
<tr class="separator:a2545e88ca6e05c22f4692625df46e228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab317d6173d3f83be92a911217430d80a" id="r_ab317d6173d3f83be92a911217430d80a"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab317d6173d3f83be92a911217430d80a">back</a> () const</td></tr>
<tr class="memdesc:ab317d6173d3f83be92a911217430d80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element of host vector (const)  <br /></td></tr>
<tr class="separator:ab317d6173d3f83be92a911217430d80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fc8fe6778a837f1d73d39fc60f94a8" id="r_a31fc8fe6778a837f1d73d39fc60f94a8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31fc8fe6778a837f1d73d39fc60f94a8">begin</a> ()</td></tr>
<tr class="memdesc:a31fc8fe6778a837f1d73d39fc60f94a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets iterator to the first element of host vector.  <br /></td></tr>
<tr class="separator:a31fc8fe6778a837f1d73d39fc60f94a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abb11152f07b1fa1ef3adc6d4af14c2" id="r_a5abb11152f07b1fa1ef3adc6d4af14c2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5abb11152f07b1fa1ef3adc6d4af14c2">end</a> ()</td></tr>
<tr class="memdesc:a5abb11152f07b1fa1ef3adc6d4af14c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets iterator to one past the last element.  <br /></td></tr>
<tr class="separator:a5abb11152f07b1fa1ef3adc6d4af14c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6341e70d6a0468b560a4133fd70f1d8e" id="r_a6341e70d6a0468b560a4133fd70f1d8e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6341e70d6a0468b560a4133fd70f1d8e">begin</a> () const</td></tr>
<tr class="memdesc:a6341e70d6a0468b560a4133fd70f1d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets const iterator to the first element.  <br /></td></tr>
<tr class="separator:a6341e70d6a0468b560a4133fd70f1d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec944c75cd4635b3f8ce7a56dabdcac" id="r_a5ec944c75cd4635b3f8ce7a56dabdcac"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ec944c75cd4635b3f8ce7a56dabdcac">end</a> () const</td></tr>
<tr class="memdesc:a5ec944c75cd4635b3f8ce7a56dabdcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets const iterator to one past the last element.  <br /></td></tr>
<tr class="separator:a5ec944c75cd4635b3f8ce7a56dabdcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class DeviceVector&lt; T &gt;</div>
<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00077">77</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3868859e1e687fc6b0c8d050b682e71a" name="a3868859e1e687fc6b0c8d050b682e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3868859e1e687fc6b0c8d050b682e71a">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, std::vector&lt;bool&gt;::reference, T &amp;&gt;</div>
</div><!-- fragment -->
<p>Reference type that handles std::vector&lt;bool&gt; specialization. </p>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00084">84</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afdcbf51472ba0977651859a9996644a6" name="afdcbf51472ba0977651859a9996644a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcbf51472ba0977651859a9996644a6">&#9670;&#160;</a></span>DeviceVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;<a class="el" href="class_device_vector.html">::DeviceVector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that initializes the host vector without GPU allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Initial size of the host vector (defaults to 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Host vector is created with 'size' default-constructed elements </dd>
<dd>
Device pointer is nullptr (no GPU memory allocated) </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00091">91</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af321e03c1e3ae97c55422b192bd41400" name="af321e03c1e3ae97c55422b192bd41400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af321e03c1e3ae97c55422b192bd41400">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces host vector contents with n copies of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to assign </td></tr>
    <tr><td class="paramname">value</td><td>Value to fill the vector with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Host vector contains exactly n elements </dd>
<dd>
All elements are copies of value </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00169">169</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a522f1cd75f0251151eaa7d2a16fad27b" name="a522f1cd75f0251151eaa7d2a16fad27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522f1cd75f0251151eaa7d2a16fad27b">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe element access for host vector with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the element to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the host vector element at specified index </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Performs bounds checking unlike operator[] </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if idx &gt;= <a class="el" href="#aaf707b4614c501b08ab94ff9035ab482" title="Returns the number of elements in the host vector.">size()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00253">253</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a2f168be854b36b73bcb7d73507da2e3d" name="a2f168be854b36b73bcb7d73507da2e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f168be854b36b73bcb7d73507da2e3d">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe const element access for host vector with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the element to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the host vector element at specified index </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Performs bounds checking unlike operator[] </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if idx &gt;= <a class="el" href="#aaf707b4614c501b08ab94ff9035ab482" title="Returns the number of elements in the host vector.">size()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00263">263</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a2545e88ca6e05c22f4692625df46e228" name="a2545e88ca6e05c22f4692625df46e228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2545e88ca6e05c22f4692625df46e228">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access last element of host vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Vector must not be empty </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if vector is empty </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00290">290</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="ab317d6173d3f83be92a911217430d80a" name="ab317d6173d3f83be92a911217430d80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab317d6173d3f83be92a911217430d80a">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access last element of host vector (const) </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the last element </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Vector must not be empty </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if vector is empty </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00299">299</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a31fc8fe6778a837f1d73d39fc60f94a8" name="a31fc8fe6778a837f1d73d39fc60f94a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fc8fe6778a837f1d73d39fc60f94a8">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets iterator to the first element of host vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the beginning </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Enables range-based for loop support </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00307">307</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a6341e70d6a0468b560a4133fd70f1d8e" name="a6341e70d6a0468b560a4133fd70f1d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6341e70d6a0468b560a4133fd70f1d8e">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets const iterator to the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the beginning </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Iterator only valid for host memory </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00323">323</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="ace3dc7de0a1a194c2cc4714f0eb40bd1" name="ace3dc7de0a1a194c2cc4714f0eb40bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3dc7de0a1a194c2cc4714f0eb40bd1">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the host vector. </p>
<dl class="section post"><dt>Postcondition</dt><dd>Host vector becomes empty (size = 0) </dd>
<dd>
Capacity remains unchanged </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00135">135</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="afd3102239a0555af7f8679b3eccc290e" name="afd3102239a0555af7f8679b3eccc290e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3102239a0555af7f8679b3eccc290e">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets pointer to contiguous host memory array. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first element in host memory </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns nullptr if vector is empty </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00235">235</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a7be36f08d2e77995f7b7a9b7e2c83de5" name="a7be36f08d2e77995f7b7a9b7e2c83de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be36f08d2e77995f7b7a9b7e2c83de5">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets const pointer to contiguous host memory array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const pointer to the first element in host memory </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns nullptr if vector is empty </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00243">243</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="aa785610e19b2e1ed8db98162a237c771" name="aa785610e19b2e1ed8db98162a237c771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa785610e19b2e1ed8db98162a237c771">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the host vector contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the host vector is empty, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00159">159</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a5abb11152f07b1fa1ef3adc6d4af14c2" name="a5abb11152f07b1fa1ef3adc6d4af14c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abb11152f07b1fa1ef3adc6d4af14c2">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets iterator to one past the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the end </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Required for range-based for loop support </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00315">315</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a5ec944c75cd4635b3f8ce7a56dabdcac" name="a5ec944c75cd4635b3f8ce7a56dabdcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec944c75cd4635b3f8ce7a56dabdcac">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets const iterator to one past the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the end </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Iterator only valid for host memory </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00331">331</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a871c733dd79a61d38df58485f59d34a5" name="a871c733dd79a61d38df58485f59d34a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871c733dd79a61d38df58485f59d34a5">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access first element of host vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Vector must not be empty </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if vector is empty </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00272">272</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="ad8b47d0c50a48722d2bab574bb15c9c4" name="ad8b47d0c50a48722d2bab574bb15c9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b47d0c50a48722d2bab574bb15c9c4">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access first element of host vector (const) </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the first element </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Vector must not be empty </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if vector is empty </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00281">281</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a7774106ac9314254e1d96db4bffb6ad1" name="a7774106ac9314254e1d96db4bffb6ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7774106ac9314254e1d96db4bffb6ad1">&#9670;&#160;</a></span>getHostVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::getHostVector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a copy of the host vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the host vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00183">183</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="aecb016c38909025c94fabb482db4c52b" name="aecb016c38909025c94fabb482db4c52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb016c38909025c94fabb482db4c52b">&#9670;&#160;</a></span>getHostVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; T &gt; &amp; <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::getHostVector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a const reference to the underlying host vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the host vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00176">176</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a32cbb4eb407e0dd8ebafa6391aa54d2a" name="a32cbb4eb407e0dd8ebafa6391aa54d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cbb4eb407e0dd8ebafa6391aa54d2a">&#9670;&#160;</a></span>operator const std::vector&lt; T &gt; &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::operator const std::vector&lt; T &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion to const host vector reference. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the underlying host vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Allows using const <a class="el" href="class_device_vector.html">DeviceVector</a> as a const std::vector </dd>
<dd>
Thread-safe for concurrent reads </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00201">201</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a7a171a250536b005ea11dff023bf6712" name="a7a171a250536b005ea11dff023bf6712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a171a250536b005ea11dff023bf6712">&#9670;&#160;</a></span>operator std::vector&lt; T &gt; &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::operator std::vector&lt; T &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion to host vector reference. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying host vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Allows using <a class="el" href="class_device_vector.html">DeviceVector</a> as a std::vector </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Modifications affect host memory only </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00192">192</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a1171f8d5f5ae3f61ce5f5a3221225404" name="a1171f8d5f5ae3f61ce5f5a3221225404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1171f8d5f5ae3f61ce5f5a3221225404">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3868859e1e687fc6b0c8d050b682e71a">reference</a> <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array subscript operator for host vector access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the element to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference (or proxy for bool) to the element </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Using reference type alias to match std::vector&lt;bool&gt; behavior that allows bit-level manipulation </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No bounds checking is performed </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00211">211</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="aaa0af677afcccdaffa5164aab2097c61" name="aaa0af677afcccdaffa5164aab2097c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0af677afcccdaffa5164aab2097c61">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const array subscript operator for host vector access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of the element to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the element (actual bool for bool type) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Special handling for bool type to return actual bool value </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No bounds checking is performed </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00224">224</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a4a789ad4fad85e4bae46b5a0490c0aef" name="a4a789ad4fad85e4bae46b5a0490c0aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a789ad4fad85e4bae46b5a0490c0aef">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element to the end of the host vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The element to append </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>New element is added at the end of host vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only modifies host memory, device memory remains unchanged </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00107">107</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a4c7533a84e4ae5cefd6797d2e530aa91" name="a4c7533a84e4ae5cefd6797d2e530aa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7533a84e4ae5cefd6797d2e530aa91">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>new_cap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves storage in the host vector for at least new_cap elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>Minimum capacity to reserve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Host vector capacity is at least new_cap </dd></dl>
<dl class="section note"><dt>Note</dt><dd>No reallocation occurs until size exceeds new capacity </dd>
<dd>
Size remains unchanged </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00145">145</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="a513932b94e4c5f24a2ce285cb44f6a99" name="a513932b94e4c5f24a2ce285cb44f6a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513932b94e4c5f24a2ce285cb44f6a99">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>new_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the host vector to contain new_size elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>New size of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Host vector contains exactly new_size elements </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only affects host memory, device memory size remains unchanged </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00116">116</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="af27d2dbdd58c11853492dc49eb1c7b6b" name="af27d2dbdd58c11853492dc49eb1c7b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27d2dbdd58c11853492dc49eb1c7b6b">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>new_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the host vector to new_size elements, initializing new elements with value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>New size of the vector </td></tr>
    <tr><td class="paramname">value</td><td>Value to initialize new elements with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Host vector contains exactly new_size elements </dd>
<dd>
New elements (if any) are copies of value </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only affects host memory, device memory size remains unchanged </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00127">127</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<a id="aaf707b4614c501b08ab94ff9035ab482" name="aaf707b4614c501b08ab94ff9035ab482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf707b4614c501b08ab94ff9035ab482">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_device_vector.html">DeviceVector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the host vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Current number of elements in host vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="_device_vector_8h_source.html#l00152">152</a> of file <a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Simulator/Utils/<a class="el" href="_device_vector_8h_source.html">DeviceVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
